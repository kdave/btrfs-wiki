This page lists the main on-disk data structures, and how they link with each other (and via which trees). It doesn't document every single field of every structure. Instead, it concentrates on the cross-links between items in the on-disk data structures.

See also: [[Btree Items]], [[On-disk_Format]]


= Structure references =

<!-- [[File~Disk-data-structures.svg|[[Image:660px-Disk-data-structures.svg.png|660px|Disk-data-structures.svg]]]] -->
[[File:References.png]]

= btrfs_block_group_item =

This structure defines the location, properties, and usage of a block group. It is associated with the <code>[[On-disk_Format#BLOCK_GROUP_ITEM|BLOCK_GROUP_ITEM]]</code>. This structure is never used outside of this item.

{|class="wikitable"
!colspan="4"|struct btrfs_block_group_item (24 bytes)
|-
!offset
!type
!field
!description
|-
|<code>0</code>
|<code>__le64</code>
|<code>used</code>
|The space used in this block group.
|-
|<code>8</code>
|<code>__le64</code>
|<code>chunk_objectid</code>
|The objectid of the chunk backing this block group.
|-
|<code>16</code>
|<code>__le64</code>
|<code>flags</code>
|See [[#btrfs_block_group_item_flags|below]].
|}

==<div id="btrfs_block_group_item_flags">Flags</div>==

<b>Allocation Type</b>
:The type of storage this block group offers. <code>SYSTEM</code> chunks cannot be mixed, but <code>DATA</code> and <code>METADATA</code> chunks can be mixed.
*<code>BTRFS_BLOCK_GROUP_DATA [0x1]</code>
*<code>BTRFS_BLOCK_GROUP_SYSTEM [0x2]</code>
*<code>BTRFS_BLOCK_GROUP_METADATA [0x4]</code>

<b>Replication Policy</b>
:The allocation policy this block group implements. Only one of the following flags may be set in any single block group. It is not possible to combine policies to create [https://en.wikipedia.org/wiki/Nested_RAID_levels nested RAID levels] beyond the RAID-10 support offered below. If no flags are specified, the block group is not replicated beyond a single, unstriped copy.
*<code>BTRFS_BLOCK_GROUP_RAID0 [0x8]</code>
:Striping ([https://en.wikipedia.org/wiki/Standard_RAID_levels#RAID_0 RAID-0])
*<code>BTRFS_BLOCK_GROUP_RAID1 [0x10]</code>
:Mirror on a separate device  ([https://en.wikipedia.org/wiki/Standard_RAID_levels#RAID_1 RAID-1])
*<code>BTRFS_BLOCK_GROUP_DUP [0x20]</code>
:Mirror on a single device
*<code>BTRFS_BLOCK_GROUP_RAID10 [0x40]</code>
:Striping and mirroring  ([https://en.wikipedia.org/wiki/Nested_RAID_levels#RAID_10 RAID-10])
*<code>BTRFS_BLOCK_GROUP_RAID5 [0x80]</code>
:Parity striping with single-disk fault tolerance ([https://en.wikipedia.org/wiki/Standard_RAID_levels#RAID_5 RAID-5])
*<code>BTRFS_BLOCK_GROUP_RAID6 [0x100]</code>
:Parity striping with double-disk fault tolerance ([https://en.wikipedia.org/wiki/Standard_RAID_levels#RAID_6 RAID-6])

= btrfs_chunk =

This structure contains the mapping from a virtualized usable byte range within the backing storage to a set of one or more stripes on individual backing devices. In addition to the mapping, hints on optimal I/O parameters for this chunk.  It is associated with <code>[[On-disk_Format#CHUNK_ITEM|CHUNK_ITEM]]</code> items.

Although the structure definition only contains one <code>stripe</code> member, <code>[[On-disk_Format#CHUNK_ITEM|CHUNK_ITEM]]</code> items contain as many <code>[[#btrfs_stripe|struct btrfs_stripe]]</code> structures as specified in the <code>num_stripes</code> and <code>sub_stripes</code> fields.

{|class="wikitable"
!colspan="4"|struct btrfs_chunk (80 bytes)
|-
!offset
!type
!field
!description
|-
|<code>0</code>
|<code>__le64</code>
|<code>length</code>
|Size of this chunk, in bytes.
|-
|<code>8</code>
|<code>__le64</code>
|<code>owner</code>
|Objectid of the root referencing this chunk; Always <code>[[On-disk_Format#EXTENT_ROOT|EXTENT_ROOT]]</code>.
|-
|<code>16</code>
|<code>__le64</code>
|<code>stripe_len</code>
|Replication stripe length.
|-
|<code>24</code>
|<code>__le64</code>
|<code>type</code>
|Uses the same flags as [[#btrfs_block_group_item_flags|btrfs_block_group_item]].
|-
|<code>32</code>
|<code>__le32</code>
|<code>io_align</code>
|Optimal I/O alignment for this chunk.
|-
|<code>36</code>
|<code>__le32</code>
|<code>io_width</code>
|Optimal I/O width for this chunk.
|-
|<code>40</code>
|<code>__le32</code>
|<code>sector_size</code>
|Minimal I/O size for this chunk.
|-
|<code>44</code>
|<code>__le16</code>
|<code>num_stripes</code>
|Number of replication stripes.
|-
|<code>46</code>
|<code>__le16</code>
|<code>sub_stripes</code>
|Number of replication sub-stripes (used only for RAID-10).
|-
|<code>48</code>
|<code>[[#btrfs_stripe|struct btrfs_stripe]]</code>
|<code>stripe</code>
|The first of one or more stripes that map to device extents.
|}

= btrfs_csum_item =

No external references

; csum 
: Start of a variable-length sequence of [currently 4-byte] checksums, one for each 4k of data, starting at the '''offset''' field of the key.

= btrfs_dev_extent =

This structure is used to map physical extents on an individual backing device to a chunk. This extent may be the only one for a particular chunk or one of several. It is associated with the <code>[[On-disk_Format#DEV_ITEM|DEV_ITEM]]</code> item. This structure is never used outside of this item.

{|class="wikitable"
!colspan="4"|struct btrfs_dev_extent (48 bytes)
|-
!offset
!type
!field
!description
|-
|<code>0</code>
|<code>__le64</code>
|<code>chunk_tree</code>
|Objectid of the <code>[[On-disk_Format#CHUNK_TREE|CHUNK_TREE]]</code> that owns this extent.
Always <code>[[On-disk_Format#BTRFS_CHUNK_TREE_OBJECTID|BTRFS_CHUNK_TREE_OBJECTID]]</code>.
|-
|<code>8</code>
|<code>__le64</code>
|<code>chunk_objectid</code>
|Objectid of the <code>[[On-disk_Format#CHUNK_ITEM|CHUNK_ITEM]]</code> that references this extent.<br />
In practice, it will always be <code>[[On-disk_Format#BTRFS_FIRST_CHUNK_TREE_OBJECTID|BTRFS_FIRST_CHUNK_TREE_OBJECTID]]</code>.
|-
|<code>16</code>
|<code>__le64</code>
|<code>chunk_offset</code>
|Offset of the <code>[[On-disk_Format#CHUNK_ITEM|CHUNK_ITEM]]</code> that references this extent.
|-
|<code>24</code>
|<code>__le64</code>
|<code>length</code>
|Length of this extent, in bytes.
|-
|<code>32</code>
|<code>__u8[16]</code>
|<code>chunk_tree_uuid</code>
|UUID of the <code>[[On-disk_Format#CHUNK_TREE|CHUNK_TREE]]</code> that owns this extent.
|}

It is unclear whether the <code>chunk_tree</code> and <code>chunk_tree_uuid</code> fields are a remnant of an early design or included for potential future expansion.

= btrfs_dev_item =

Represents a complete block device.

; devid 
: Matches the devid in the filesystem's list of struct btrfs_devices.

{|class="wikitable"
!colspan="4"|struct btrfs_dev_item (98 bytes)
|-
!offset
!type
!field
!description
|-
|<code>0</code>
|<code>__le64</code>
|<code>devid</code>
|the internal btrfs device id
|-
|<code>8</code>
|<code>__le64</code>
|<code>total_bytes</code>
|size of the device
|-
|<code>16</code>
|<code>__le64</code>
|<code>bytes_used</code>
| bytes used
|-
|<code>24</code>
|<code>__le32</code>
|<code>io_align</code>
|optimal io alignment for this device
|-
|<code>28</code>
|<code>__le32</code>
|<code>io_width</code>
|optimal io width for this device
|-
|<code>32</code>
|<code>__le32</code>
|<code>sector_size</code>
|minimal io size for this device
|-
|<code>36</code>
|<code>__le64</code>
|<code>type</code>
|type and info about this device
|-
|<code>44</code>
|<code>__le64</code>
|<code>generation</code>
|expected generation for this device
|-
|<code>52</code>
|<code>__le64</code>
|<code>start_offset</code>
|starting byte of this partition on the device,
to allow for stripe alignment in the future
|-
|<code>60</code>
|<code>__le32</code>
|<code>dev_group</code>
|grouping information for allocation decisions
|-
|<code>64</code>
|<code>__u8</code>
|<code>seek_speed</code>
|seek speed 0-100 where 100 is fastest
|-
|<code>65</code>
|<code>__u8</code>
|<code>bandwidth</code>
|bandwidth 0-100 where 100 is fastest 
|-
|<code>66</code>
|<code>__u8[16]</code>
|<code>uuid</code>
|btrfs generated uuid for this device
|-
|<code>82</code>
|<code>__u8[16]</code>
|<code>fsid</code>
|uuid of FS who owns this device
|}

= btrfs_dev_stats_item =

This device item holds various statistics about a device. This item type is contained only in the [[On-disk_Format#Dev_tree_.284.29|DEV_TREE]]

{|class="wikitable"
!colspan="4"|struct btrfs_dev_stats_item (40 bytes)
|-
!offset
!type
!field
!description
|-
|<code>0</code>
|<code>_le64</code>
|<code>values[6]</code>
|Array of stats values. See below
|}

== Stat items ==

The codes below signify a direct disk I/O failures:

* <code>BTRFS_DEV_STAT_WRITE_ERRS 0x1</code> 
:Number of times we got EIO or EREMOTEIO from lower layers while performing writes
   
* <code>BTRFS_DEV_STAT_READ_ERRS 0x2</code>
:Number of times we got EIO or EREMOTEIO from lower layers while performing reads   

* <code>BTRFS_DEV_STAT_FLUSH_ERRS 0x3</code>
:Number of times we got EIO or EREMOTEIO from lower layers while performing data flushes  
                                                                                
The codes below indicate an indirect I/O failure: 

* <code>BTRFS_DEV_STAT_CORRUPTION_ERRS 0x4</code>
:checksum error, bytenr error or  contents is illegal: this is an indication that the block was damaged during read or write, or written to  wrong location or read from wrong  location   
                      
* <code>BTRFS_DEV_STAT_GENERATION_ERRS 0x5</code>
:an indication that blocks have not been written

= btrfs_dev_replace_item = 

This item holds necessary information to resume a device replace operation following a crash/suspend. It is contained in [[On-disk_Format#Dev_tree_.284.29|DEV_TREE]]

{|class="wikitable"
!colspan="4"|struct btrfs_dev_replace_item (72 bytes)
|-
!offset
!type
!field
!description
|-
|<code>0</code>
|<code>__le64</code>
|<code>src_devid</code>
|Device id of the source device
|-
|<code>8</code>
|<code>__le64</code>
|<code>cursor_left</code>
|
|-
|<code>16</code>
|<code>__le64</code>
|<code>cursor_right</code>
|
|-
|<code>24</code>
|<code>__le64</code>
|<code>cont_reading_from_srcdev_mode</code>
|
|-
|<code>32</code>
|<code>__le64</code>
|<code>replace_state</code>
|State of replace operation. Can be one of: <code>BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED, BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED,
BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED, BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED, BTRFS_IOCTL_DEV_REPLACE_STATE_STARTED</code>
|-
|<code>40</code>
|<code>__le64</code>
|<code>time_started</code>
| 
|-
|<code>48</code>
|<code>__le64</code>
|<code>time_stopped</code>
|
|-
|<code>56</code>
|<code>__le64</code>
|<code>num_write_errors</code>
|expected generation for this device
|-
|<code>64</code>
|<code>__le64</code>
|<code>num_uncorrectable_read_errors</code>
|
|}

= btrfs_balance_item =
TODO


= btrfs_dir_item =

This structure represents the header for a directory entry item used for both standard user-visible directories and internal directories used to manage named extended attributes. It is associated with the <code>[[On-disk_Format#DIR_ITEM|DIR_ITEM]]</code> and <code>[[On-disk_Format#XATTR_ITEM|XATTR_ITEM]]</code> items. This structure is not used outside of these items.

It is immediately followed by the name. If it represents an extended attribute, the attribute data immediately follows the name.

{|class="wikitable"
!colspan="4"|struct btrfs_dir_item (30 bytes)
|-
!offset
!type
!field
!description
|-
|<code>0</code>
|<code>[[#btrfs_disk_key|struct btrfs_disk_key]]</code>
|<code>location</code>
|Key for the <code>[[On-disk_Format#INODE_ITEM|INODE_ITEM]]</code> or <code> [[On-disk_Format#ROOT_ITEM|ROOT_ITEM]]</code> associated with this entry. <br/>
Unused and zeroed out when the entry describes an extended attribute.
|-
|<code>17</code>
|<code>__le64</code>
|<code>transid</code>
|<code>transid</code> of the transaction that created this entry.
|-
|<code>25</code>
|<code>__le16</code>
|<code>data_len</code>
|Length of the extended attribute associated with this entry.
<code>0</code> for standard directories.
|-
|<code>27</code>
|<code>__le16</code>
|<code>name_len</code>
|Length of directory entry name.
|-
|<code>29</code>
|<code>__u8</code>
|<code>type</code>
|See [[#btrfs_dir_item_types|below]].
|}

==<div id="btrfs_dir_item_types">Types</div>==
These directory entry types use the same values as the <code>d_type</code> field in <code>struct dirent</code> documented in the <code>readdir(3)</code> manual page.

* <code>BTRFS_FT_UNKNOWN = 0</code>
:The target object's type is unknown. Indicates corruption if used.
*<code>BTRFS_FT_REG_FILE = 1</code>
:The target object is an <code>[[On-disk_Format#INODE_ITEM|INODE_ITEM]]</code> representing a regular file.
*<code>BTRFS_FT_DIR = 2</code>
:The target object is an <code>[[On-disk_Format#INODE_ITEM|INODE_ITEM]]</code> representing a directory or a <code>[[On-disk_Format#ROOT_ITEM|ROOT_ITEM]]</code> that will be presented as a directory.
*<code>BTRFS_FT_CHRDEV = 3</code>
:The target object is an <code>[[On-disk_Format#INODE_ITEM|INODE_ITEM]]</code> representing a character device node.
*<code>BTRFS_FT_BLKDEV = 4</code>
:The target object is an <code>[[On-disk_Format#INODE_ITEM|INODE_ITEM]]</code> representing a block device node.
*<code>BTRFS_FT_FIFO = 5</code>
:The target object is an <code>[[On-disk_Format#INODE_ITEM|INODE_ITEM]]</code> representing a FIFO device node.
*<code>BTRFS_FT_SOCK = 6</code>
:The target object is an <code>[[On-disk_Format#INODE_ITEM|INODE_ITEM]]</code> representing a socket device node.
*<code>BTRFS_FT_SYMLINK = 7</code>
:The target object is an <code>[[On-disk_Format#INODE_ITEM|INODE_ITEM]]</code> representing a symbolic link.


This value is used on-disk and internally but is not user-visible.
*<code>BTRFS_FT_XATTR = 8</code>
:The entry is an <code>[[On-disk_Format#XATTR_ITEM|XATTR_ITEM]]</code>.

= btrfs_dir_log_item =
TODO

{|class="wikitable"
!colspan="4"|struct btrfs_dir_log_item (8 bytes)
|-
!offset
!type
!field
!description
|-
|<code>0</code>
|<code>__le64</code>
|<code>end</code>
|
|}

= btrfs_extent_data_ref =

This structure contains an indirect back reference for a file data extent.

Follows a <code>[[#btrfs extent inline ref|btrfs_extent_inline_ref]]</code> of type <code>[[Data_Structures#btrfs_extent_inline_ref_types| BTRFS_EXTENT_DATA_REF_KEY]]</code> within an <code>[[On-disk_Format#EXTENT_ITEM|EXTENT_ITEM]]</code> item. It is never used separately outside of the item body. Note that this structure is located at the same offset as the <code>offset</code> member of the <code>[[#btrfs extent inline ref|btrfs_extent_inline_ref]]</code> that it follows. 

{|class="wikitable"
!colspan="4"|struct btrfs_extent_data_ref (28 bytes)
|-
!offset
!type
!field
!description
|-
|<code>0</code>
|<code>__le64</code>
|<code>root</code>
|The objectid for the file tree that references this extent.
|-
|<code>8</code>
|<code>__le64</code>
|<code>objectid</code>
|The objectid of the inode that contains the [[On-disk_Format#EXTENT_DATA|EXTENT_DATA]] item that references this extent.
|-
|<code>16</code>
|<code>__le64</code>
|<code>offset</code>
|The offset within the file that corresponds to this extent.
|-
|<code>24</code>
|<code>__le32</code>
|<code>count</code>
|The number of references held.
|}

TODO: Document how count can be > 1 for a single [root, objectid, EXTENT_DATA, offset] item.

= btrfs_extent_inline_ref =

This structure functions as the header for several types of inline extent back references that are contained in [[On-disk_Format#EXTENT_ITEM|EXTENT_ITEM]] or [[On-disk_Format#METADATA_ITEM|METADATA_ITEM]] items. This structure is never used separately outside of these items.

{|class="wikitable"
!colspan="4"|struct btrfs_extent_inline_ref (9 bytes)
|-
!offset
!type
!field
!description
|-
|<code>0</code>
|<code>u8</code>
|<code>type</code>
|One of 4 key types, listed below.
|-
|<code>1</code>
|<code>__le64</code>
|<code>offset</code>
|Contents depend on type of reference.
|}

==<div id="btrfs_extent_inline_ref_types">Types</div>==

* <code>BTRFS_TREE_BLOCK_REF_KEY [176]</code>
:The back reference is indirect for a tree block. <code>offset</code> contains the <code>objectid</code> of the tree root that allocated the block.
*<code>BTRFS_SHARED_BLOCK_REF_KEY [182]</code>
:The back reference is shared for a tree block. <code>offset</code> contains the byte offset of the node at the next higher level in the tree where this block is located.
*<code>BTRFS_EXTENT_DATA_REF_KEY [178]</code>
:The back reference is indirect for a data extent. <code>offset</code> is unused and a <code>[[#btrfs_extent_data_ref |btrfs_extent_data_ref]]</code> structure is located immediately after the <code>type</code> field.
*<code>BTRFS_SHARED_DATA_REF_KEY [184]</code>
:The back reference is shared for a data extent. <code>offset</code> contains the byte offset of the metadata block that contains the [[On-disk_Format#EXTENT_DATA|EXTENT_DATA]] item that describes this extent. Immediately following is a <code>[[#btrfs_shared_data_ref|btrfs_shared_data_ref]]</code> structure containing the reference count.

= btrfs_extent_item =

This structure functions as the header for extent record items. It is associated with the <code>[[On-disk_Format#EXTENT_ITEM|EXTENT_ITEM]]</code> and <code>[[On-disk_Format#METADATA_ITEM|METADATA_ITEM]]</code> types.

One extent record item exists for each extent allocated on a btrfs file system. Each item tracks the number of explicit references to the extent (TODO: document implied references), records whether the extent contains file data or tree metadata and, if the latter, if the item contains a full back reference. It is followed by back reference records for each explicit reference held.

If the item type containing this item is <code>EXTENT_ITEM</code> and the <code>BTRFS_EXTENT_FLAG_TREE_BLOCK</code> flag is set, this item will be followed immediately by a <code>[[#btrfs tree block info|btrfs_tree_block_info]]</code>. Extent records follow this, as below.

For all item types, a series of variable-length extent records will fill the rest of the item. Each of these records will begin with a <code>[[#btrfs extent inline ref|btrfs_extent_inline_ref]]</code>, with the contents of each record determined by the header's <code>type</code> field.

{|class="wikitable"
!colspan="4"|struct btrfs_extent_item (24 bytes)
|-
!offset
!type
!field
!description
|-
|<code>0</code>
|<code>__le64</code>
|<code>refs</code>
|The number of explicit references to this extent
|-
|<code>8</code>
|<code>__le64</code>
|<code>generation</code>
|<code>transid</code> of transaction that allocated this extent
|-
|<code>16</code>
|<code>__le64</code>
|<code>flags</code>
|see [[#btrfs_extent_item_flags|below]]
|}

==<div id="btrfs_extent_item_flags">Flags</div>==
*<code>BTRFS_EXTENT_FLAG_DATA [0x1]</code>
:Flag to indicate that the following record refers to a data extent

*<code>BTRFS_EXTENT_FLAG_TREE_BLOCK [0x2]</code>
: Flag to indicate that the following record refers to a metadata tree block
:*<code>BTRFS_BLOCK_FLAG_FULL_BACKREF [0x80]</code>
:: Tree block back reference contains a full back reference.

= btrfs_extent_ref_v0 =

= btrfs_file_extent_item =

Represents a chunk of data on disk belonging to a file. In the fs-trees, the corresponding key is ''(<inum> EXTENT_DATA <logical offset>)''. The ''<logical offset>'' is in (uncompressed) bytes within the file belonging to inode ''<inum>''.

{|class="wikitable"
!colspan="4"|struct btrfs_file_extent_item (53 bytes)
|-
!offset
!type
!field
!description
|-
|<code>0</code>
|<code>__le64</code>
|<code>generation</code>
|transaction id that created this extent
|-
|<code>8</code>
|<code>__le64</code>
|<code>ram_bytes</code>
|Upper limit on the size of the extent in ram
|-
|<code>16</code>
|<code>__u8</code>
|<code>compression</code>
|Compression type. Can be one of: BTRFS_COMPRESS_NONE (0),  BTRFS_COMPRESS_ZLIB (1) and BTRFS_COMPRESS_LZO (2)
|-
|<code>17</code>
|<code>__u8</code>
|<code>encryption</code>
|encryption type, currently always set to 0
|-
|<code>18</code>
|<code>__le16</code>
|<code>other_encoding</code>
|Currently unused, allows for future expansion. 
|-
|<code>20</code>
|<code>__u8</code>
|<code>type</code>
|Type of extent. Can be BTRFS_FILE_EXTENT_INLINE (0), BTRFS_FILE_EXTENT_REG (1) or BTRFS_FILE_EXTENT_PREALLOC (2). For inline extents the file contents immediately follow the type byte. The length of the inline data block equals ''ram_bytes'', alternatively it can be read from the inode or computed as the size stored in the corresponding btrfs_item-structure less the (partial) size of the btrfs_file_extent_item-structure.
|-
!colspan="4"|<i>The following fields apply to BTRFS_FILE_EXTENT_REG/BTRFS_FILE_EXTENT_PREALLOC extents only</i>
|-
|<code>21</code>
|<code>__le64</code>
|<code>disk_bytenr</code>
|Logical address for the start of the extent data. Note: This is the key.''objectid'' for the corresponding EXTENT_ITEM.
|-
|<code>29</code>
|<code>__le64</code>
|<code>disk_num_bytes</code>
|Number of on-disk bytes of the extent (compressed). Note: This is the key.''offset'' for the corresponding EXTENT_ITEM.
|-
|<code>37</code>
|<code>__le64</code>
|<code>offset</code>
|Offset into the extent item. Number of bytes to skip at the beginning (uncompressed).
|-
|<code>45</code>
|<code>__le64</code>
|<code>num_bytes</code>
|Number of valid bytes within the file extent item (uncompressed). This always reflects the size uncompressed and without encoding.
|}

= btrfs_file_extent_item_v0 =
TODO

= btrfs_free_space_entry =
TODO

= btrfs_free_space_header =
TODO

= btrfs_free_space_info =
This struct is only used with space_cache v2.
Every block group is represented in the free space tree by a free space info item, which stores some accounting information.

It is keyed on (block_group_start, FREE_SPACE_INFO, block_group_length).

{|class="wikitable"
!colspan="4"|struct btrfs_inode_ref (8 bytes)
|-
!offset
!type
!field
!description
|-
|<code>0</code>
|<code>__le32</code>
|<code>extent_count</code>
|Number of extents that are tracking the free space for this block group
|-
|<code>4</code>
|<code>__le32</code>
|<code>flags</code>
|Flags associated with this free_space_info (current it can be 0 or BTRFS_FREE_SPACE_BITMAP_KEY)
|}

= btrfs_inode_ref =
Indexed by (inode_number, BTRFS_INODE_REF_ITEM, parent_inode). Allows you to find the btrfs_dir_item entries or the filename for a given inode. There is one of these for each hard-linked copy of a file.

{|class="wikitable"
!colspan="4"|struct btrfs_inode_ref (10 bytes)
|-
!offset
!type
!field
!description
|-
|<code>0</code>
|<code>__le64</code>
|<code>index</code>
|Index of the inode this item's referencing in the directory
|-
|<code>8</code>
|<code>__le16</code>
|<code>name_len</code>
|length of the name, following this item
|}

= btrfs_inode_extref = 
TODO

=btrfs_inode_item=

This structure contains the information typically associated with a UNIX-style inode's <code>stat(2)</code> data. It is associated with the <code>[[On-disk_Format#INODE_ITEM|INODE_ITEM]]</code>.

{|class="wikitable"
!colspan="4"|struct btrfs_inode_item (160 bytes)
|-
!offset
!type
!field
!description
|-
|<code>0</code>
|<code>__le64</code>
|<code>generation</code>
|
|-
|<code>8</code>
|<code>__le64</code>
|<code>transid</code>
|
|-
|<code>16</code>
|<code>__le64</code>
|<code>size</code>
|<code>stat.st_size</code>; Size of the file in bytes.
|-
|<code>24</code>
|<code>__le64</code>
|<code>nbytes</code>
|<code>stat.st_blocks</code> in byte units. Size allocated to this file, in bytes; <br/>Sum of the offset fields of all <code>[[On-disk_Format#EXTENT_DATA|EXTENT_DATA]]</code> items for this inode. For directories: <code>0</code>.
|-
|<code>32</code>
|<code>__le64</code>
|<code>block_group</code>
|Unused for normal inodes. Contains byte offset of block group when used as a free space inode.
|-
|<code>40</code>
|<code>__le32</code>
|<code>nlink</code>
|<code>stat.st_nlink</code>; Count of <code>[[On-disk_Format#INODE_REF|INODE_REF]]</code> entries for the inode. When used outside of a file tree, <code>1</code>.
|-
|<code>44</code>
|<code>__le32</code>
|<code>uid</code>
|<code>stat.st_uid</code>
|-
|<code>48</code>
|<code>__le32</code>
|<code>gid</code>
|<code>stat.st_gid</code>
|-
|<code>52</code>
|<code>__le32</code>
|<code>mode</code>
|<code>stat.st_mode</code>
|-
|<code>56</code>
|<code>__le64</code>
|<code>rdev</code>
|<code>stat.st_rdev</code>
|-
|<code>64</code>
|<code>__le64</code>
|<code>flags</code>
|Inode flags, see [[#btrfs_inode_item_flags|below]].
|-
|<code>72</code>
|<code>__le64</code>
|<code>sequence</code>
|Sequence number used for NFS compatibility. Initialized to <code>0</code> and incremented each time <code>mtime</code> value is changed.
|-
|<code>80</code>
|<code>__le64</code>
|<code>reserved[4]</code>
|<i>Reserved for future use.</i>
|-
|<code>112</code>
|<code>struct btrfs_timespec</code>
|<code>atime</code>
|<code>stat.st_atime</code>
|-
|<code>124</code>
|<code>struct btrfs_timespec</code>
|<code>ctime</code>
|<code>stat.st_ctime</code>
|-
|<code>136</code>
|<code>struct btrfs_timespec</code>
|<code>mtime</code>
|<code>stat.st_mtime</code>
|-
|<code>148</code>
|<code>struct btrfs_timespec</code>
|<code>otime</code>
|Timestamp of inode creation.
|}

==<div id="btrfs_inode_item_flags">Flags</div>==

NOTE: The <i>unimplemented</i> status of any of these flags was evaluated against Linux 4.11-rc2.

*<code>BTRFS_INODE_NODATASUM [0x1]</code>
: Do not perform checksum operations on this inode.

*<code>BTRFS_INODE_NODATACOW [0x2]</code>
: Do not perform CoW for data extents on this inode when the reference count is <code>1</code>.

*<code>BTRFS_INODE_READONLY [0x4]</code>
: Inode is read-only regardless of UNIX permissions or ownership.
:*This bit is still checked and returns <code>EACCES</code> but there is no way to set it. That suggests that it has been superseded by <code>BTRFS_INODE_IMMUTABLE</code>.

*<code>BTRFS_INODE_NOCOMPRESS [0x8]</code>
: Do not compress this inode.
:* This flag may be changed by the kernel as compression ratios change. If the compression ratio for data associated with an inode becomes undesirable, this flag will be set. It may be cleared if the data changes and the compression ratio is favorable again.

*<code>BTRFS_INODE_PREALLOC [0x10]</code>
: Inode contains preallocated extents. This instructs the kernel to attempt to avoid CoWing those extents.

*<code>BTRFS_INODE_SYNC [0x20]</code>
: Operations on this inode will be performed synchronously.
:*This flag is converted to a VFS-level inode flag but is not handled anywhere.

*<code>BTRFS_INODE_IMMUTABLE [0x40]</code>
: Inode is read-only regardless of UNIX permissions or ownership. Attempts to modify this inode will result in <code>EPERM</code> being returned to the user.

*<code>BTRFS_INODE_APPEND [0x80]</code>
: This inode is append-only.

*<code>BTRFS_INODE_NODUMP [0x100]</code>
: This inode is not a candidate for dumping using the <code>dump(8)</code> program.
:*<i>This flag will be accepted on all kernels but is not implemented</i>

*<code>BTRFS_INODE_NOATIME [0x200]</code>
: Do not update <code>atime]</code> when this inode is accessed.

*<code>BTRFS_INODE_DIRSYNC [0x400]</code>
: Operations on directory operations will be performed synchronously.
:*This flag is converted to a VFS-level inode flag but is not handled anywhere.

*<code>BTRFS_INODE_COMPRESS [0x800]</code>
: Compression is enabled on this inode.

= btrfs_header =

Every tree block (leaf or node) starts with this header.

; bytenr 
: virtual address of block 
; owner 
: the object id of the tree this block belongs to, for example BTRFS_ROOT_TREE_OBJECTID

= <span id="btrfs_key">btrfs_key</span> / <span id="btrfs_disk_key">btrfs_disk_key</span> =

The <code>btrfs_key</code> is one of the fundamental btrfs data structures. Every item in every tree in the file system is located using its key. The <code>btrfs_key</code> can be more accurately described as a 3-tuple used to locate any item in any tree in the file system.

<code>btrfs_key</code> objects only exists in memory and is in CPU byte order. <code>btrfs_disk_key</code> is identical to <code>btrfs_key</code> except that <code>objectid</code> and <code>offset</code> are in little endian (disk) byte order and are part of the file system on-disk format.


{|class="wikitable"
!colspan="4"|struct btrfs_key and struct btrfs_disk_key (17 bytes)
|-
!offset
!type
!field
!description
|-
|<code>0</code>
|<code>u64 or __le64</code>
|<code>objectid</code>
|The object identifier for this item
|-
|<code>8</code>
|<code>u8</code>
|<code>type</code>
|The type of the item this key describes
|-
|<code>9</code>
|<code>u64 or __le64</code>
|<code>offset</code>
|More accurately described as "third component." It is literally an offset only in some contexts.
|}


The <code>objectid</code> field contains a value that is defined by the tree in which it is located. For example, in the [[On-disk_Format#EXTENT_TREE|EXTENT_TREE]], the <code>objectid</code> contains the starting byte offset of the extent it describes.

The <code>type</code> field is universal. It always contains the type of the item identified by the key. There are no changes in usage or context that depend on the tree using the key.

The <code>offset</code> field contains a value that is defined by the item type. For example, keys of <code>type = [[On-disk_Format#EXTENT_ITEM|EXTENT_ITEM]]</code> use the <code>offset</code> to store the size of the extent the item describes.  Keys of <code>type = [[On-disk_Format#METADATA_ITEM|METADATA_ITEM]]</code> use the <code>offset</code> to store the level of the tree where the tree block is located.

= btrfs_root_item =

This structure holds defines the the root of a btree. It is associated with the [[On-disk_Format#ROOT_ITEM|ROOT_ITEM]] type. This structure is never used outside of this item.

{|class="wikitable"
!colspan="4"|struct btrfs_root_item (439 bytes)
|-
!offset
!type
!field
!description
|-
|<code>0</code>
|<code>[[#btrfs_inode_item|struct btrfs_inode_item]]</code>
|<code>inode</code>
|Several fields are initialized but only <code>flags</code> is interpreted at runtime.
<code>generation=1</code>, <code>size=3</code>,<code>nlink=1</code>, <code>nbytes=<leafsize></code>, <code>mode=040755</code><br />
<code>flags</code> depends on kernel version, see [[#btrfs_root_item_inode_flags|below]].
|-
|<code>160</code>
|<code>__le64</code>
|<code>generation</code>
|<code>transid</code> of the transaction that created this root.
|-
|<code>168</code>
|<code>__le64</code>
|<code>root_dirid</code>
|For file trees, the objectid of the root directory in this tree (always <code>256</code>).
Otherwise, <code>0</code>.
|-
|<code>176</code>
|<code>__le64</code>
|<code>bytenr</code>
|The disk offset in bytes for the root node of this tree.
|-
|<code>184</code>
|<code>__le64</code>
|<code>byte_limit</code>
|<i>Unused</i>. Always <code>0</code>.
|-
|<code>192</code>
|<code>__le64</code>
|<code>bytes_used</code>
|<i>Unused</i>.
|-
|<code>200</code>
|<code>__le64</code>
|<code>last_snapshot</code>
|The last <code>transid</code> of the transaction that created a snapshot of this root.
|-
|<code>208</code>
|<code>__le64</code>
|<code>flags</code>
|See [[#btrfs_root_item_flags|below]].
|-
|<code>216</code>
|<code>__le32</code>
|<code>refs</code>
|Originally indicated a reference count. In modern usage, it is only <code>0</code> or <code>1</code>.
|-
|<code>220</code>
|<code>[[#btrfs_disk_key|struct btrfs_disk_key]]</code>
|<code>drop_progress</code>
|Contains key of last dropped item during subvolume removal or relocation. Zeroed otherwise.
|-
|<code>237</code>
|<code>__u8</code>
|<code>drop_level</code>
|The tree level of the node described in <code>drop_progress</code>.
|-
|<code>238</code>
|<code>__u8</code>
|<code>level</code>
|The height of the tree rooted at <code>bytenr</code>.
|-
!colspan="4"|<i>The following fields depend on the subvol_uuids+subvol_times features</i>
|-
|<code>239</code>
|<code>__le64</code>
|<code>generation_v2</code>
|If equal to <code>generation</code>, indicates validity of the following fields.<br />If the root is modified using an older kernel, this field and <code>generation</code> will become out of sync. This is normal and recoverable.
|-
|<code>247</code>
|<code>u8[16]</code>
|<code>uuid</code>
|This subvolume's UUID.
|-
|<code>263</code>
|<code>u8[16]</code>
|<code>parent_uuid</code>
|The parent's UUID (for use with send/receive).
|-
|<code>279</code>
|<code>u8[16]</code>
|<code>received_uuid</code>
|The received UUID (for used with send/receive).
|-
|<code>295</code>
|<code>__le64</code>
|<code>ctransid</code>
|The <code>transid</code> of the last transaction that modified this tree, with some exceptions (like the internal caches or relocation).
|-
|<code>303</code>
|<code>__le64</code>
|<code>otransid</code>
|The <code>transid</code> of the transaction that created this tree.
|-
|<code>311</code>
|<code>__le64</code>
|<code>stransid</code>
|The <code>transid</code> for the transaction that sent this subvolume. Nonzero for received subvolume.
|-
|<code>319</code>
|<code>__le64</code>
|<code>rtransid</code>
|The <code>transid</code> for the transaction that received this subvolume. Nonzero for received subvolume.
|-
|<code>327</code>
|<code>[[#btrfs_timespec|struct btrfs_timespec]]</code>
|<code>ctime</code>
|Timestamp for <code>ctransid</code>.
|-
|<code>339</code>
|<code>[[#btrfs_timespec|struct btrfs_timespec]]</code>
|<code>otime</code>
|Timestamp for <code>otransid</code>.
|-
|<code>351</code>
|<code>[[#btrfs_timespec|struct btrfs_timespec]]</code>
|<code>stime</code>
|Timestamp for <code>stransid</code>.
|-
|<code>363</code>
|<code>[[#btrfs_timespec|struct btrfs_timespec]]</code>
|<code>rtime</code>
|Timestamp for <code>rtransid</code>.
|-
|<code>375</code>
|<code>__le64[8]</code>
|<code>reserved</code>
|Reserved for future use.
|}

==Flags==
<div id="btrfs_root_item_flags"><code>btrfs_root_item.flags</code></div>
*<code>BTRFS_ROOT_SUBVOL_RDONLY [0x1]</code>
:Flag to indicate that this root is read-only.

<div id="btrfs_root_item_inode_flags"><code>btrfs_inode_item.flags</code></div>
: In addition to flags documented at [[#btrfs_inode_item_flags|btrfs_inode_item]].
* <code>BTRFS_INODE_ROOT_ITEM_INIT [1 << 31]</code>
: Flag to indicate that the flags and byte_limit flags have been properly initialized.

= btrfs_root_ref =

References a subvolume fs tree root. Used for both forward and backward root refs. The name of the tree is stored after the end of the struct

{|class="wikitable"
!colspan="4"|struct btrfs_root_ref (18 bytes)
|-
!offset
!type
!field
!description
|-
|<code>0</code>
|<code>__le64</code>
|<code>dirid</code>
|Subtree ID.
|-
|<code>8</code>
|<code>__le64</code>
|<code>sequence</code>
|Directory sequence number of subtree entry
|-
|<code>16</code>
|<code>__le16</code>
|<code>name_len</code>
|Length of subtree name 
|}

= btrfs_shared_data_ref =

This structure contains the count for a shared back reference for a file data extent.

Follows a btrfs_extent_inline_ref of type BTRFS_SHARED_DATA_REF_KEY within an EXTENT_ITEM item. It is never used separately outside of the item body. It immediately follows the <code>[[#btrfs extent inline ref|btrfs_extent_inline_ref]]</code> structure that contains the byte offset of the metadata leaf block that contains the [[On-disk_Format#EXTENT_DATA|EXTENT_DATA]] item that references this extent.

{|class="wikitable"
!colspan="4"|struct btrfs_shared_data_ref (4 bytes)
|-
!offset
!type
!field
!description
|-
|<code>0</code>
|<code>__le32</code>
|<code>count</code>
|Number of references held.
|}

= btrfs_stripe =

This structure is used to define the backing device storage that compose a btrfs <b>chunk</b>. It is associated with the <code>[[On-disk_Format#CHUNK_ITEM|CHUNK_ITEM]]</code> item. This structure is never used outside of this item.

{|class="wikitable"
!colspan="4"|struct btrfs_stripe (32 bytes)
|-
!offset
!type
!field
!description
|-
|<code>0</code>
|<code>__le64</code>
|devid
|Device ID that contains this stripe.
|-
|<code>8</code>
|<code>__le64</code>
|offset
|Location of the start of the stripe, in bytes.<br />
Size is determined by the <code>stripe_len</code> field in <code>[[#btrfs_chunk|struct btrfs_chunk]]</code>.
|-
|<code>16</code>
|<code>__u8[16]</code>
|dev_uuid
|UUID of the device that contains this stripe. Used to confirm that the correct device has been retrieved.
|}


The <code>devid</code> and <code>offset</code> fields are used to construct a key to retrieve a <code>[[On-disk_Format#DEV_ITEM|DEV_ITEM]]</code> from the <code>[[On-disk_Format#DEV_TREE|DEV_TREE]]</code>. The key takes the following form.
{|class="wikitable"
!colspan="3"|struct btrfs_key
|-
!<code>objectid</code>
!<code>type</code>
!<code>offset</code>
|-
|<code>devid</code>
|<code>BTRFS_DEV_ITEM_KEY [216]</code>
|<code>offset</code>
|}

= btrfs_super_block =
The primary superblock is located at 0x1 0000 (64<sub>10</sub> KiB). Mirror copies of the superblock are located at physical addresses 0x400 0000 (64<sub>10</sub> MiB), 0x40 0000 0000 (256<sub>10</sub> GiB), and 0x4 0000 0000 0000 (1 PiB), if these locations are valid. btrfs normally updates all superblocks, but in SSD mode it will update only one at a time. The superblock with the highest generation is used when reading.

Note that btrfs only recognizes disks with a valid 0x1 0000 superblock; otherwise, there would be confusion with other filesystems.

TODO

{| class="wikitable" border="1"
!colspan="5"|struct btrfs_super_block 
|-
! Off
! Size
! Type
! field
! Description
|-
| align="right" | 0
| align="right" | 20
| u8[BTRFS_CSUM_SIZE]
| csum
| Checksum of everything past this field (from 20 to 1000)
|-
| align="right" | 20
| align="right" | 10
| u8[BTRFS_FSID_SIZE]
| fsid
| FS UUID
|-
| align="right" | 30
| align="right" | 8
| __le64
| bytenr
| physical address of this block (different for mirrors)
|-
| align="right" | 38
| align="right" | 8
|
| __le64
| flags
|-
| align="right" | 40
| align="right" | 8
| __le64
| magic
| magic ("_BHRfS_M")
|-
| align="right" | 48
| align="right" | 8
| __le64
| generation
| generation
|-
| align="right" | 50
| align="right" | 8
| __le64
| root
| logical address of the root tree root
|-
| align="right" | 58
| align="right" | 8
| __le64
| chunck_root
|
logical address of the [[#Chunk tree .283.29|chunk tree]] root
|-
| align="right" | 60
| align="right" | 8
| __le64
| log_root
| logical address of the log tree root
|-
| align="right" | 68
| align="right" | 8
| __le64
| log_root_transid
| log_root_transid
|-
| align="right" | 70
| align="right" | 8
| __le64
| total_bytes
| total_bytes
|-
| align="right" | 78
| align="right" | 8
| __le64
| bytes_used
| bytes_used
|-
| align="right" | 80
| align="right" | 8
| __le64
| root_dir_objectid
| root_dir_objectid (usually 6)
|-
| align="right" | 88
| align="right" | 8
| __le64
| num_devices
| num_devices
|-
| align="right" | 90
| align="right" | 4
| __le64
| sectorsize
| sectorsize
|-
| align="right" | 94
| align="right" | 4
| __le64
| nodesize
| nodesize
|-
| align="right" | 98
| align="right" | 4
| __le64
| __unused_leafsize
| leafsize
|-
| align="right" | 9c
| align="right" | 4
| __le64
| stripesize
| stripesize
|-
| align="right" | a0
| align="right" | 4
| __le64
| sys_chunk_array_size
| sys_chunk_array_size
|-
| align="right" | a4
| align="right" | 8
| __le64
| chunk_root_generation
| chunk_root_generation
|-
| align="right" | ac
| align="right" | 8
| __le64
| compat_flags
| compat_flags
|-
| align="right" | b4
| align="right" | 8
| __le64
| compat_ro_flags
| compat_ro_flags - only implementations that support the flags can write to the filesystem
|-
| align="right" | bc
| align="right" | 8
| __le64
| incompat_flags
| incompat_flags - only implementations that support the flags can use the filesystem
|-
| align="right" | c4
| align="right" | 2
| __le64
| csum_type
| csum_type - Btrfs currently uses the CRC32c little-endian hash function with seed -1.
|-
| align="right" | c6
| align="right" | 1
| u8
| root_level
| root_level
|-
| align="right" | c7
| align="right" | 1
| u8
| chunk_root_level
| chunk_root_level
|-
| align="right" | c8
| align="right" | 1
| u8
| log_root_level
| log_root_level
|-
| align="right" | c9
| align="right" | 62
| btrfs_dev_item
| dev_item
|
[[#DEV ITEM .28d8.29|DEV_ITEM]] data for this device
|-
| align="right" | 12b
| align="right" | 100
| char[BTRFS_LABEL_SIZE]
| label
| label (may not contain '/' or '\\')
|-
| align="right" | 22b
| align="right" | 8
| __le64
| cache_generation
| cache_generation
|-
| align="right" | 233
| align="right" | 8
| __le64
| uuid_tree+generation
| uuid_tree_generation
|-
| align="right" | 23b
| align="right" | f0
| __le64
| reserved[30]
| reserved /* future expansion */
|-
| align="right" | 32b
| align="right" | 800
| u8
| sys_chunk_array[BTRFS_SYSTEM_CHUNK_ARRAY_SIZE]
|
sys_chunk_array:(''n'' bytes valid) Contains (KEY, [[#CHUNK ITEM .28e4.29|CHUNK_ITEM]]) pairs for all SYSTEM chunks. This is needed to bootstrap the mapping from logical addresses to physical.
|-
| align="right" | b2b
| align="right" | 2a0
| btrfs_root_backup
| super_roots[BTRFS_NUM_BACKUP_ROOTS]
| Contain super_roots (4 btrfs_root_backup)
|-
| align="right" | dcb
| align="right" | 235
|
|
| current unused
|-
| colspan="5" | 1000
|}

= btrfs_timespec =

= btrfs_tree_block_info =

This structure contains the level of tree at which the node described this back reference is located. It contains a field for the first key within the tree block it describes but the field is considered unused.

This structure always follows a <code>[[#btrfs_extent_item|struct btrfs_extent_item]]</code> within an <code>[[On-disk_Format#EXTENT_ITEM|EXTENT_ITEM]]</code> with the <code>[[Data_Structures#btrfs_extent_item_flags|BTRFS_EXTENT_FLAG_TREE_BLOCK]]</code> flag set and is followed by one or more <code>[[#btrfs extent inline ref|struct btrfs_extent_inline_ref]] records</code>.

Newer file systems with the [[Feature:Skinny_Metadata|skinny metadata]] feature enabled use <code>[[On-disk_Format#METADATA_ITEM|METADATA_ITEM]]</code> items instead, which eliminate the need for this separate structure.

{|class="wikitable"
!colspan="4"|struct btrfs_tree_block_info (18 bytes)
|-
!offset
!type
!field
!description
|-
|<code>0</code>
|<code>struct btrfs_disk_key</code>
|<code><strike>key</strike></code>
|<i>Although this value may be accurate, it's unused.</i>
|-
|<code>17</code>
|<code>__u8</code>
|<code>level</code>
|<code>Level of the tree that contains this node</code>
|}

= btrfs_qgroup_status_item =

One item per quota tree. Holds information about quota state. 

{|class="wikitable"
!colspan="4"|struct btrfs_qgroup_status_item (32 bytes)
|-
!offset
!type
!field
!description
|-
|<code>0</code>
|<code>__le64</code>
|<code>version</code>
|Quota version. Currently always set to 1 (BTRFS_QGROUP_STATUS_VERSION)
|-
|<code>8</code>
|<code>__le64</code>
|<code>generation</code>
|Number updated during every commit. Used to check for inconsistencies
|-
|<code>16</code>
|<code>__le64</code>
|<code>flags</code>
|See [[#btrfs_qgroup_status_item_flags|below]].
|-
|<code>24</code>
|<code>__le64</code>
|<code>rescan</code>
|Used during rescan to record the progress. It contains a logical address.
|}

== Flags ==
*<code>BTRFS_QGROUP_STATUS_FLAG_ON [0x1]</code>
: subvolume quota turned on.

*<code>BTRFS_QGROUP_STATUS_FLAG_RESCAN [0x2]</code>
: Signals whether rescan is in progress.                   

*<code>BTRFS_QGROUP_STATUS_FLAG_INCONSISTENT [0x4]</code>
: Turned on when some qgroup entries are known to be out of date, either because the configuration has changed in a certain way that requires rescan or because the fs has been mounted with a non-qgroup-aware version. Turning qouta off and on again makes it inconsistent, too.

= btrfs_qgroup_info_item =

One item per qgroup. Holds information about number of bytes used by this qgroup. 

{|class="wikitable"
!colspan="4"|struct btrfs_qgroup_info_item (40 bytes)
|-
!offset
!type
!field
!description
|-
|<code>0</code>
|<code>__le64</code>
|<code>generation</code>
|Id of transaction that modified this qgroup item
|-
|<code>8</code>
|<code>__le64</code>
|<code>rfer</code>
|Referenced bytes (including shared data)
|-
|<code>16</code>
|<code>__le64</code>
|<code>rfer_cmpr</code>
|Referenced bytes compressed
|-
|<code>24</code>
|<code>__le64</code>
|<code>excl</code>
|Exclusive data referenced
|-
|<code>32</code>
|<code>__le64</code>
|<code>excl_cmpr</code>
|Exclusive compressed bytes
|}

= btrfs_qgroup_limit_item =

One item per qgroup (pairs with btrfs_qgroup_info_item). Holds information about enabled limits for a qgroup

{|class="wikitable"
!colspan="4"|struct btrfs_qgroup_limit_item (40 bytes)
|-
!offset
!type
!field
!description
|-
|<code>0</code>
|<code>__le64</code>
|<code>flags</code>
|Contains information about enabled limits. See [[#btrfs_qgroup_limit_item|below]]
|-
|<code>8</code>
|<code>__le64</code>
|<code>max_rfer</code>
|Maximum amount of referenced data allowed
|-
|<code>16</code>
|<code>__le64</code>
|<code>max_excl</code>
|Maximum amount of exclusive data allowed
|-
|<code>24</code>
|<code>__le64</code>
|<code>rsv_rfer</code>
|Unused 
|-
|<code>32</code>
|<code>__le64</code>
|<code>rsv_excl</code>
|Unused
|}

== Flags ==

*<code>BTRFS_QGROUP_LIMIT_MAX_RFER [0x1]</code>
: Limit on maximum referenced data enabled

*<code>BTRFS_QGROUP_LIMIT_MAX_EXCL [0x2]</code>
: Limit on maximum eclusive data enabled                 

*<code>BTRFS_QGROUP_LIMIT_RSV_RFER [0x4]</code>
: Unused

*<code>BTRFS_QGROUP_LIMIT_RSV_EXCL [0x8]</code>
: Unused

*<code>BTRFS_QGROUP_LIMIT_RFER_CMPR [0x10]</code>
: Limit on maximum compressed referenced data enabled

*<code>BTRFS_QGROUP_LIMIT_EXCL_CMPR [0x20]</code>
: Limit on maximum exclusive compressed data size enabled
                    
[[Category:CodeDoc]]