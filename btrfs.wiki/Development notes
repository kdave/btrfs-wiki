Collection of various notes about development practices, how-to's or checklists.

= Misc notes =

== Adding a new ioctl, extending an existing one ==

* add code to [https://github.com/strace/strace strace] so the ioctl calls are parsed into a human readable form. Most of the ioctls are already [https://github.com/strace/strace/blob/master/btrfs.c implemented] and can be used a reference.

== Tracepoints ==

The tracepoint message format should be compact and consistent, so please
stick to the following format:

* ''key=value'' no spaces around ''=''
* separated by spaces, not commas
* named values: print value and string, like "%llu(%s)", no space between, string in parens
* avoid abbreviating key values too much, (eg. use 'size' not 'sz')
* hexadecimal values are always preceded by ''0x'' (use "0x%llx)
* use ''struct btrfs_inode'' for inode types, not plain ''struct inode''
* inode number type is ''u64'', use ''btrfs_ino'' if needed
* key can be printed as ''[%llu,%u,%llu]''
* enum types need to be exported as ''TRACE_DEFINE_ENUM''

'''Example:'''

event: ''btrfs__chunk''

string:

   "root=%llu(%s) offset=%llu size=%llu num_stripes=%d sub_stripes=%d type=%s"

== Error messages, verbosity ==

* use ''btrfs_*'' helpers (btrfs_err, btrfs_info, ...), they print a filesystem identification like
 BTRFS info (device sdb): ...
* first letter in the string is lowercase
* message contents
** be descriptive
** keep the text length reasonable (fits one line without wrapping)
** no typos
** print values that refer to what happend (inode number, subvolume id, path, offset, ...)
** print error value from the last call
** no ''"\n"'' at the end of the string
** no ''".'''' at the end of text
** un-indent the string so it fits under 80 columns
** don't split long strings, overflow 80 is ok in this case (we want to be able to search for the error messages in the sources easily)
* value representation
** decimal: offsets, length, ordinary numbers
** hexadecimal: checksums
** hexadecimal + string: bitmasks (eg. raid profiles, flags)
** intervals of integers:
*** closed interval (end values inclusive): [0, 4096]
*** half-open (right value excluded): [0, 4096)
*** half-open (left value excluded): (0, 4096] -- that one may look strange but is used in several places

=== Message level ===

* btrfs_err -- such messages have high visibility so use them for serious problems that need user attention
* btrfs_warn -- conditions that are not too serious but can point to potential problems, the system should be still in a good state
* btrfs_info -- use for informative messages that are useful to see what's happening in the filesystem or might help debugging problems in the future and are worth keeping in the logs

== Error handling and transaction abort ==

Please keep all transaction abort exactly at the place where they happen and
do not merge them to one. This pattern should be used everwhere and is
important when debugging because we can pinpoint the line in the code from the
syslog message and do not have to guess which way it got to the merged call.

== Handling unexpected conditions ==

This is different than error handling. An unexpected condtion happens when the code invariants/assumptions do not hold and there's no way to recover from the situation. This means that returning an error to the caller can't be done and continuing would only propagate the logic error further. The reasons for that bug can be two fold: internal (a genuine bug) or external (eg. memory biflip, memory corrupted by other subystem). In this case it is allowed to use the nuclear option and do BUG_ON, that is otherwise highly discouraged.

There are several ways how to react to the unexpected conditions:

* ASSERT -- conditionally compiled in and crashes when the condition is false, this is supposed to catch 'must never happen' at the time of development, code must not continue
* WARN_ON -- light check that is visible in the log and allows the code to continue but the reasons must be investigated
* BUG_ON -- last resort, checks condition that 'must never happen' and continuing would cause more harm than the instant crash; code should always try to avoid using it, but there are cases when sanity and invariant checks are done in advance

== BCP ==

* do not use <tt>spin_is_locked</tt> but <tt>lockdep_assert_held</tt>

= Coding style preferences =

Before applying recommendations from this sections, please make sure you're familiar with the [https://www.kernel.org/doc/html/latest/process/coding-style.html|generic kernel coding style guide].

* comment new data structures
* comment new enum/define values, brief description or pointers to the code that uses them

= Kernel config options =

== Testing ==

Compile-time config options for kernel that can help debugging, testing.
They usually take a hit on performance or resources (memory) so they should be
selected wisely. The options in '''bold''' should be safe to use by default
for debugging builds.

Please refer to the option documentation for further details.

* devices for testing
** '''CONFIG_BLK_DEV_LOOP''' - enable loop device
** for fstests: '''DM_FLAKEY''', '''CONFIG_FAIL_MAKE_REQUEST'''
** '''CONFIG_SCSI_DEBUG''' - fake scsi block device
* memory
** '''CONFIG_SLUB_DEBUG''' - boot with slub_debug
** CONFIG_DEBUG_PAGEALLOC + CONFIG_DEBUG_PAGEALLOC_ENABLE_DEFAULT (on newer kernels)
** CONFIG_PAGE_POISONING
** CONFIG_HAVE_DEBUG_KMEMLEAK
** CONFIG_FAILSLAB
* btrfs
** '''CONFIG_BTRFS_DEBUG''', '''CONFIG_BTRFS_ASSERT''', '''CONFIG_BTRFS_FS_RUN_SANITY_TESTS'''
** '''CONFIG_BTRFS_FS_CHECK_INTEGRITY'''
* locking
** CONFIG_DEBUG_SPINLOCK, CONFIG_DEBUG_MUTEXES
** CONFIG_DEBUG_LOCK_ALLOC
** CONFIG_PROVE_LOCKING, CONFIG_LOCKDEP
** CONFIG_LOCK_STAT
** CONFIG_PROVE_RCU
* sanity checks
** CONFIG_DEBUG_STACK_USAGE, CONFIG_HAVE_DEBUG_STACKOVERFLOW, CONFIG_DEBUG_STACKOVERFLOW
** CONFIG_STACKTRACE
** kasan
* verbose reporting
** CONFIG_DEBUG_BUGVERBOSE
* tracing
** CONFIG_TRACING etc

= (x)fstests =

The fstests suite has very few "hard" requirements and will succeed without actually running many tests.  In order to ensure full test coverage, your test environment should provide the settings from the following sections. Please note that newly added tests silently add new dependencies, so you should always review results after an update.
 
== Kernel config options for complete test coverage ==
* <code>CONFIG_FAULT_INJECTION=y</code>
* <code>CONFIG_FAULT_INJECTION_DEBUG_FS=y</code>
* <code>CONFIG_FAIL_MAKE_REQUEST=y</code>
* <code>CONFIG_DM_FLAKEY=m</code> or <code>y</code>
* <code>CONFIG_DM_THIN_PROVISIONING=m</code> or <code>y</code>
* <code>CONFIG_DM_SNAPSHOT=m</code> or <code>y</code>
* <code>CONFIG_DM_DELAY=m</code> or <code>y</code>
* <code>CONFIG_DM_ERROR=m</code> or <code>y</code>
* <code>CONFIG_DM_LOG_WRITES=m</code> or <code>y</code>
* <code>CONFIG_BLK_DEV_LOOP=m</code> or <code>y</code>
* <code>CONFIG_EXT4_FS=m</code> or <code>y</code>
* <code>CONFIG_SCSI_DEBUG=m</code>

== Kernel config options for better bug reports ==

See the list in the section above for more options.

== User space utilities and development library dependencies ==
* fio
* dmsetup (device-mapper)
* lvm
* xfsprogs >= 4.3.1
** <code>xfs_io -c reflink</code> is required.
* btrfsprogs
* dbench
* openssl
* libacl
* libattr
* libaio
* libuuid
* libcap-progs
* duperemove
----
Note: This list may be incomplete.

== Storage environment ==
* At least 4 identically sized partitions/disks/virtual disks, specified using <code>$SCRATCH_DEV_POOL</code>
** some tests may require 6 such partitions
* some tests need at least 10G of free space, as determined by <code>df</code>, ie. the size of the device may need to be larger
* some tests require <code>$LOGWRITES_DEV</code>, yet another separate block device, for power fail testing
* for testing trim and discard, the devices must be capable of that (physical or virtual)

== Other requirements ==
* An <code>fsgqa</code> user and group must exist.
* An <code>123456-fsgqa</code> user and group must exist.